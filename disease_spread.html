<!DOCTYPE html>
<html>

<head>
  <title>JSXGraph Example</title>
  <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
  <style>
    #box {
      width: 600px;
      height: 600px;
    }
  </style>
</head>

<body>

  <div id="box" class="jxgbox"></div>
  <div>
    <button onclick="start()"> Start </button>
    <button onclick="pause()"> Pause </button>
    <button onclick="continueSim()"> Continue </button>
  </div>

  <script>
    const board = JXG.JSXGraph.initBoard('box', {
      boundingbox: [-1, 30, 30, -1],
      axis: false
    });
    const g = board.create('grid', [], {});

    const sliderXStart = 1;
    const sliderXEnd = 5;
    const firstSliderY = 3;
    const secondSliderY = 2;
    const thirdSliderY = 1;

    // slider: number of individuals
    const sliderIndividuals = board.create('slider', [
      [sliderXStart, firstSliderY],
      [sliderXEnd, firstSliderY],
      [5, 20, 50]
    ], {
      name: ' Number of individuals',
      snapWidth: 1,
      precision: 0,
      layer: 10
    });

    // slider: infection chance
    const sliderInfectionChance = board.create('slider', [
      [sliderXStart, secondSliderY],
      [sliderXEnd, secondSliderY],
      [1, 50, 100]
    ], {
      name: ' Chance of infection upon contact (%)',
      snapWidth: 1,
      precision: 0,
      layer: 10
    });
    // slider: chance of death from infection
    const sliderDeathChance = board.create('slider', [
      [sliderXStart, thirdSliderY],
      [sliderXEnd, thirdSliderY],
      [0.1, 1, 8]
    ], {
      name: ' Chance of death from infection per timestep (%)',
      snapWidth: 0.1,
      precision: 1,
      layer: 10
    });

    const pointMap = new Map();
    const occupied = new Set();
    const startingPoints = [];
    const deadPoints = [];

    let numberOfIndividuals = 20;
    let infectionChance = 0.5;
    let deathChance = 0.05;
    let started = false;
    let flagKeepGoing = true;

    let stepCounter = 0;
    const counterText = board.create('text', [0, 0, 'Step: 0'])

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateIndividuals() {
      for (let i = 0; i < numberOfIndividuals; i++) {
        const x = randomInt(1, 29);
        const y = randomInt(1, 29);
        startingPoints.push([x, y]);
      }

      startingPoints.forEach(i => {
        const x = i[0];
        const y = i[1];
        createPoint(x, y);
      });

      const firstPoint = pointMap.get(1);
      firstPoint.customState = 'infected';
      firstPoint.setAttribute({ color: 'red' })
    }

    function createPoint(x, y) {
      const potentialKey = `${x},${y}`;
      if (!occupied.has(potentialKey)) {
        const id = pointMap.size + 1;
        const point = board.create('point', [x, y], {
          name: id,
          fixed: true,
          size: 5,
          color: 'blue',
          highlight: false,
          layer: 5
        });

        point.customState = 'clean';
        point.gridX = x;
        point.gridY = y;
        point.infectedOnStep = null;

        point.id = id;
        const key = `${point.gridX},${point.gridY}`;
        pointMap.set(id, point);
        occupied.add(key);
      }
    }


    function movePointRandomly(point) {
      const x = point.gridX;
      const y = point.gridY;
      let newX = x;
      let newY = y;

      const direction = Math.floor(Math.random() * 4);

      if (direction === 0 && y < 29) newY += 1;        // up
      else if (direction === 1 && y > 0) newY -= 1;    // down
      else if (direction === 2 && x > 0) newX -= 1;    // left
      else if (direction === 3 && x < 29) newX += 1;   // right
      const key = `${newX},${newY}`;

      if (!occupied.has(key) && !(newY == y && newX == x)) {
        point.moveTo([newX, newY], 200);
        occupied.delete(`${x},${y}`);
        occupied.add(key);
        point.gridX = newX;
        point.gridY = newY;
        board.update();
      }
    }


    function updateContactState(point) {
      if (point.customState == "clean") {
        const x = point.gridX;
        const y = point.gridY;

        const neighbors = [
          [x + 1, y],
          [x - 1, y],
          [x, y + 1],
          [x, y - 1],
          [x + 1, y + 1],
          [x - 1, y + 1],
          [x - 1, y - 1],
          [x - 1, y - 1],
        ];

        let inContact = false;
        for (const [nx, ny] of neighbors) {
          if (occupied.has(`${nx},${ny}`)) {
            inContact = true;
            break;
          }
        }

        if (inContact) {
          // Now find which point(s) are adjacent
          for (const [otherId, otherPoint] of pointMap) {
            if (otherId === point.id) continue; // skip self
            const dx = Math.abs(otherPoint.gridX - x);

            const dy = Math.abs(otherPoint.gridY - y);
            if ((dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0)) {
              if (otherPoint.customState == 'infected') {
                const rand = Math.random();
                if (rand < infectionChance) {
                  point.customState = 'infected';
                  point.infectedOnStep = stepCounter;
                  point.setAttribute({ color: 'red', layer: 5 });
                }
              }
            }
          }
        }
      }
    }

    function updateRecovered(point) {
      if (point.customState == 'infected' && (stepCounter - point.infectedOnStep) > 100) {
        point.customState = 'recovered';
        point.setAttribute({ color: 'orange', layer: 5 });
      }
    }

    function killPoint(id) {
      const point = pointMap.get(id);
      if (!point) return;
      
      const key = `${point.gridX},${point.gridY}`;
      pointMap.delete(id);
      occupied.delete(key);
      point.remove(); //board.removeObject didn't work for some reason
      board.update();

      const deadPoint = board.create('point', [point.gridX, point.gridY], {
        name: '',
        fixed: true,
        size: 5,
        color: 'gray',
        highlight: false,
        showInfobox: false,
        layer: 2
      });
      deadPoints.push(deadPoint); 
    }

    function updateDeaths(point) {
      if (point.customState == 'infected' && Math.random() < deathChance) {
        killPoint(point.id);
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function move() {
      while (flagKeepGoing) {
        stepCounter++;
        counterText.setText('Step: ' + stepCounter);
        await sleep(200);

        board.suspendUpdate();
        pointMap.forEach((value, key) => {
          updateContactState(value);
          movePointRandomly(value);
          updateRecovered(value);
          updateDeaths(value);
        })
        board.update();
      }
    }

    function start() {
      if (!started) {
        started = true;
        numberOfIndividuals = sliderIndividuals.Value();
        infectionChance = sliderInfectionChance.Value() / 100;
        deathChance = sliderDeathChance.Value() / 100;
        generateIndividuals();
        move();
      }
    }

    function pause() {
      flagKeepGoing = false;
    }
    function continueSim() {
      flagKeepGoing = true;
      move();
    }

  </script>

</body>

</html>