<!DOCTYPE html>
<html>

<head>
  <title>JSXGraph Example</title>
  <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
  <style>
    #box {
      width: 1200px;
      height: 600px;
    }

    div {
      margin: 8px;
    }
  </style>
</head>

<body>

  <div id="box" class="jxgbox"></div>
  <div>
    <button onclick="start()"> Start </button>
    <button onclick="pause()"> Pause </button>
    <button onclick="continueSim()"> Continue </button>
  </div>
  <div> Blue = healthy individual <br>
    Red = infected individual, can infect others <br>
    Orange = recovered individual (recovery happens 100 timesteps after infection) <br>
    Gray = individual died from infection </div>

  <script>
    //TODO: 
    // reset button 
    if (JXG.JSXGraph.boards && JXG.JSXGraph.boards.box) {
      JXG.JSXGraph.freeBoard(JXG.JSXGraph.boards.box);
    }
    const board = JXG.JSXGraph.initBoard('box', {
      boundingbox: [-1, 30, 60, -1],
      axis: false,
      showCopyright: false,
      showNavigation: false
    });
    const g = board.create('grid', [], {});
    const divider = board.create('line', [[30, 1], [30, 30]], { color: 'grey' })
    const yAxisForGraph = board.create('line', [[31, 0], [31, 31]], { color: 'black', strokeWidth: 1, straightFirst: false, straightLast: false })
    const xAxisForGraph = board.create('line', [[31, 0], [60, 0]], { color: 'black', strokeWidth: 1, straightFirst: false, straightLast: false })

    const sliderXStart = 1;
    const sliderXEnd = 5;
    const firstSliderY = 3;
    const secondSliderY = 2;
    const thirdSliderY = 1;
    const counterTextY = 29;

    // slider: number of individuals
    const sliderIndividuals = board.create('slider', [
      [sliderXStart, firstSliderY],
      [sliderXEnd, firstSliderY],
      [5, 20, 50]
    ], {
      name: ' Number of individuals',
      snapWidth: 1,
      precision: 0,
      layer: 10
    });

    // slider: infection chance
    const sliderInfectionChance = board.create('slider', [
      [sliderXStart, secondSliderY],
      [sliderXEnd, secondSliderY],
      [1, 50, 100]
    ], {
      name: ' Chance of infection upon contact (%)',
      snapWidth: 1,
      precision: 0,
      layer: 10
    });
    // slider: chance of death from infection
    const sliderDeathChance = board.create('slider', [
      [sliderXStart, thirdSliderY],
      [sliderXEnd, thirdSliderY],
      [0.1, 1, 8]
    ], {
      name: ' Chance of death from infection per timestep (%)',
      snapWidth: 0.1,
      precision: 1,
      layer: 10
    });

    const pointMap = new Map();
    const occupied = new Set();
    const startingPoints = [];
    const deadPoints = [];

    const maxSteps = 500;
    const xDivider = 17.5;

    let numberOfIndividuals = 20;
    let infectionChance = 0.5;
    let deathChance = 0.05;
    let started = false;
    let flagKeepGoing = true;

    let stepCounter = 0;
    let infectedIndividuals = 0;
    let recoveredIndividuals = 0;

    const counterText = board.create('text', [31.5, counterTextY - 1, 'Step: 0'])
    const infectedText = board.create('text', [31.5, counterTextY, 'Infected individuals: 1'])
    const recoveredText = board.create('text', [38.5, counterTextY, 'Recovered individuals: 0'])
    const deadText = board.create('text', [46.5, counterTextY, 'Dead individuals: 0'])

    const infectedCounts = [];
    const xAtStep = [];
    const graphPoints = [];
    let curve = null;



    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateIndividuals() {
      for (let i = 0; i < numberOfIndividuals; i++) {
        const x = randomInt(1, 29);
        const y = randomInt(1, 29);
        startingPoints.push([x, y]);
      }

      startingPoints.forEach(i => {
        const x = i[0];
        const y = i[1];
        createPoint(x, y);
      });

      const firstPoint = pointMap.get(1);
      firstPoint.customState = 'infected';
      firstPoint.setAttribute({ color: 'red' })
    }

    function createPoint(x, y) {
      const potentialKey = `${x},${y}`;

      const id = pointMap.size + 1;
      const point = board.create('point', [x, y], {
        name: id,
        fixed: true,
        size: 5,
        color: 'blue',
        highlight: false,
        layer: 5
      });

      point.customState = 'clean';
      point.gridX = x;
      point.gridY = y;
      point.infectedOnStep = null;

      point.id = id;
      const key = `${point.gridX},${point.gridY}`;
      pointMap.set(id, point);
      occupied.add(key);

    }


    function movePointRandomly(point) {
      const x = point.gridX;
      const y = point.gridY;
      let newX = x;
      let newY = y;

      const direction = Math.floor(Math.random() * 4);

      if (direction === 0 && y < 29) newY += 1;        // up
      else if (direction === 1 && y > 0) newY -= 1;    // down
      else if (direction === 2 && x > 0) newX -= 1;    // left
      else if (direction === 3 && x < 29) newX += 1;   // right
      const key = `${newX},${newY}`;

      if (!occupied.has(key) && !(newY == y && newX == x)) {
        point.moveTo([newX, newY], 200);
        occupied.delete(`${x},${y}`);
        occupied.add(key);
        point.gridX = newX;
        point.gridY = newY;
        board.update();
      }
    }


    function updateContactState(point) {
      if (point.customState == "clean") {
        const x = point.gridX;
        const y = point.gridY;

        const neighbors = [
          [x + 1, y],
          [x - 1, y],
          [x, y + 1],
          [x, y - 1],
          [x + 1, y + 1],
          [x - 1, y + 1],
          [x - 1, y - 1],
          [x - 1, y - 1],
        ];

        let inContact = false;
        for (const [nx, ny] of neighbors) {
          if (occupied.has(`${nx},${ny}`)) {
            inContact = true;
            break;
          }
        }

        if (inContact) {
          // Now find which point(s) are adjacent
          for (const [otherId, otherPoint] of pointMap) {
            if (otherId === point.id) continue; // skip self
            const dx = Math.abs(otherPoint.gridX - x);

            const dy = Math.abs(otherPoint.gridY - y);
            if ((dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0)) {
              if (otherPoint.customState == 'infected') {
                const rand = Math.random();
                if (rand < infectionChance && point.customState === 'clean') { //second check, though the break should make this redundant
                  point.customState = 'infected';
                  point.infectedOnStep = stepCounter;
                  point.setAttribute({ color: 'red', layer: 5 });
                  infectedIndividuals++;
                  break;
                }
              }
            }
          }
        }
      }
    }

    function updateRecovered(point) {
      if (point.customState == 'infected' && (stepCounter - point.infectedOnStep) > 100) {
        point.customState = 'recovered';
        point.setAttribute({ color: 'orange', layer: 5 });
        infectedIndividuals--;
        recoveredIndividuals++;
      }
    }

    function killPoint(id) {
      const point = pointMap.get(id);
      if (!point) return;

      const key = `${point.gridX},${point.gridY}`;
      pointMap.delete(id);
      occupied.delete(key);
      point.remove(); //board.removeObject didn't work for some reason
      board.update();
      infectedIndividuals--;

      const deadPoint = board.create('point', [point.gridX, point.gridY], {
        name: '',
        fixed: true,
        size: 5,
        color: 'gray',
        highlight: false,
        showInfobox: false,
        layer: 2
      });
      deadPoints.push(deadPoint);
    }

    function updateDeaths(point) {
      if (point.customState == 'infected' && Math.random() < deathChance) {
        killPoint(point.id);
      }
    }

    function updateCountersDisplayed() {
      counterText.setText('Step: ' + stepCounter);
      infectedText.setText('Infected individuals: ' + infectedIndividuals);
      recoveredText.setText('Recovered individuals: ' + recoveredIndividuals);
      deadText.setText('Dead individuals: ' + deadPoints.length);
    }

    function updateGraphPoints() {
      infectedCounts.push(Number(infectedIndividuals / 2));
      const num = Number((31 + stepCounter / xDivider).toPrecision(4));
      xAtStep.push(num);
      //I just couldn't get the curve to update/display, so for now I'm just removing and recreating it.
      if (curve){
        board.removeObject(curve);
      }
      if (xAtStep.length >= 2) {
        curve = board.create('curve', [
          xAtStep,
          infectedCounts
        ], {
          strokeColor: 'red',
          strokeWidth: 3,
          layer: 11
        });
      }

      board.update();

    }


    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function move() {
      while (flagKeepGoing && stepCounter < maxSteps) {
        stepCounter++;
        await sleep(100);
        board.suspendUpdate();
        pointMap.forEach((point) => {
          updateContactState(point);
          movePointRandomly(point);
        });

        const toRecover = [];
        const toKill = [];

        pointMap.forEach((point) => {
          if (point.customState === 'infected') {
            if ((stepCounter - point.infectedOnStep) > 100) {
              toRecover.push(point);
            } else if (Math.random() < deathChance) { //separation to avoid timing issue
              toKill.push(point);
            }
          }
        });

        toRecover.forEach((point) => updateRecovered(point));
        toKill.forEach((point) => killPoint(point.id));

        if (stepCounter % 5 === 0) {
          updateGraphPoints();
        }
        updateCountersDisplayed();
        board.update();
        
      }
    }

    function start() {
      if (!started) {
        started = true;
        numberOfIndividuals = sliderIndividuals.Value();
        infectionChance = sliderInfectionChance.Value() / 100;
        deathChance = sliderDeathChance.Value() / 100;
        generateIndividuals();
        infectedIndividuals++;
        move();
      }
    }

    function pause() {
      flagKeepGoing = false;
    }
    function continueSim() {
      flagKeepGoing = true;
      move();
    }



    updateGraphPoints();

  </script>

</body>

</html>