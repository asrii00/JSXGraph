<!DOCTYPE html>
<html>

<head>
  <title>JSXGraph Example</title>
  <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
  <style>
    #box {
      width: 600px;
      height: 600px;
    }
  </style>
</head>

<body>

  <div id="box" class="jxgbox"></div>
  <div>
    <button onclick="start()"> Start </button>
  </div>

  <script>//sometimes proximity detection doesn't seem to work bilaterally..? check if that's true and fix, 
    //maybe it was due to the other point being infected already
    //Ideas: 
    // - add time from infection to death

    const board = JXG.JSXGraph.initBoard('box', {
      boundingbox: [-1, 30, 30, -1],
      axis: false
    });
    const g = board.create('grid', [], {});

    const sliderXStart = 1;
    const sliderXEnd = 5;
    const firstSliderY = 3;
    const secondSliderY = 2;

    // slider: number of individuals
    const sliderIndividuals = board.create('slider', [
      [sliderXStart, firstSliderY],
      [sliderXEnd, firstSliderY],
      [5, 20, 50]
    ], {
      name: 'Number of individuals',
      snapWidth: 1,
      precision: 0,
      layer: 10
    });

    // slider: infection chance
    const sliderInfectionChance = board.create('slider', [
      [sliderXStart, secondSliderY],
      [sliderXEnd, secondSliderY],
      [1, 50, 100]
    ], {
      name: 'Chance of infection upon contact (%)',
      snapWidth: 1,
      precision: 0,
      layer: 10
    });

    const pointMap = new Map();
    const occupied = new Set();
    let numberOfIndividuals = 1;
    let infectionChance = 0.5;
    let started = false;
    let flagKeepGoing = true;
    const points = [];
    const startingPoints = [];

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateIndividuals() {
      //add check to avoid overlap

      for (let i = 0; i < numberOfIndividuals; i++) {
        const x = randomInt(1, 29);
        const y = randomInt(1, 29);
        startingPoints.push([x, y]);
      }

      startingPoints.forEach(i => {
        const x = i[0];
        const y = i[1];
        createPoint(x, y);
      });

      const firstPoint = pointMap.get(1);
      firstPoint.customState = 'infected';
      firstPoint.setAttribute({ color: 'red' })
    }

    function createPoint(x, y) {
      const potentialKey = `${x},${y}`;
      if (!occupied.has(potentialKey)) {
        const id = pointMap.size + 1;
        const point = board.create('point', [x, y], {
          name: id,
          fixed: true,
          size: 5,
          color: 'blue',
          highlight: false,
          layer: 5
        });

        point.customState = 'clean';
        point.gridX = x;
        point.gridY = y;

        point.id = id;
        const key = `${point.gridX},${point.gridY}`;
        pointMap.set(id, point);
        occupied.add(key);
      }
    }


    function movePointRandomly(point) {
      const x = point.gridX;
      const y = point.gridY;
      let newX = x;
      let newY = y;

      const direction = Math.floor(Math.random() * 4);

      if (direction === 0 && y < 29) newY += 1;        // up
      else if (direction === 1 && y > 0) newY -= 1;    // down
      else if (direction === 2 && x > 0) newX -= 1;    // left
      else if (direction === 3 && x < 29) newX += 1;   // right
      const key = `${newX},${newY}`;

      if (!occupied.has(key) && !(newY == y && newX == x)) {
        point.moveTo([newX, newY], 200);
        occupied.delete(`${x},${y}`);
        occupied.add(key);
        point.gridX = newX;
        point.gridY = newY;
        board.update();
      }

    }


    function updateContactState(point) {
      if (point.customState == "clean") {
        const x = point.gridX;
        const y = point.gridY;

        const neighbors = [
          [x + 1, y],
          [x - 1, y],
          [x, y + 1],
          [x, y - 1],
          [x + 1, y + 1],
          [x - 1, y + 1],
          [x - 1, y - 1],
          [x - 1, y - 1],
        ];

        let inContact = false;
        for (const [nx, ny] of neighbors) {
          if (occupied.has(`${nx},${ny}`)) {
            inContact = true;
            break;
          }
        }

        if (inContact) {
          // Now find which point(s) are adjacent
          for (const [otherId, otherPoint] of pointMap) {
            if (otherId === point.id) continue; // skip self
            const dx = Math.abs(otherPoint.gridX - x);

            const dy = Math.abs(otherPoint.gridY - y);
            if ((dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0)) {
              if (otherPoint.customState == 'infected') {
                const rand = Math.random();
                if (rand < infectionChance) {
                  point.customState = 'infected';
                  point.setAttribute({ color: 'red', layer: 5 });
                }
              }
            }
          }
        }
      }
    }


    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function move() {
      while (flagKeepGoing) {
        await sleep(200);
        for (const point of pointMap.values()) {
          updateContactState(point);
        }
        board.suspendUpdate();
        pointMap.forEach((value, key) => {
          movePointRandomly(value);
        })
        board.update();
      }
    }

    function start() {
      if (!started) {
        started = true;
        numberOfIndividuals = sliderIndividuals.Value();
        infectionChance = sliderInfectionChance.Value() / 100;
        generateIndividuals();
        move();
      }
    }

  </script>

</body>

</html>