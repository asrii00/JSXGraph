<!DOCTYPE html>
<html>

<head>
    <title>JSXGraph Example</title>
    <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
    <style>
        #box {
            width: 900px;
            height: 600px;
        }

        div {
            margin: 7px;
        }
    </style>
</head>

<body>
    <div id="box" class="jxgbox"></div>
    <div class="flex">
        <button onClick="step()"> Step </button>
        <button onClick="tenStep()"> 10 steps </button>
        <button onClick="reset()"> Reset </button>
    </div>



    <script>

        //TODO: make altitude component less strict
        const board = JXG.JSXGraph.initBoard('box', {
            boundingbox: [-1, 21, 31, -1],
            axis: true,
            showCopyright: false,
            showNavigation: false
        });

        const gridSize = 20;
        const cellSize = 0.5;
        const baseDeathProbability = 0.05;
        const baseOffspringProbability = 0.4;

        const startX = 9.5; //square x = 10
        const startY = 10.5;

        let individuals = [];
        const foodBits = [];
        const rectangles = [];

        const occupied = new Set(); //needs grid to work so not utilized atm
        const occupiedFood = new Set();

        let hasStarted = false;
        let stepCounter = 0;
        let altitudePref = 0.33;

        const aliveColor = "#68C93E";
        const deadFromDrought = "#6D5F3E";
        

        //const s0 = board.create('slider', [[21, 5], [25, 5], [0, 0.33, 1]], { name: 'Altitude preference' });

        const stepLabel = board.create('text', [21, 19.5, function () {
            return 'Current timestep: ' + stepCounter;
        }], {
            anchorX: 'left',
            anchorY: 'top',
            fontSize: 20,
            fixed: true,
            highlight: false,
            cssStyle: `background-color: rgba(111, 163, 230, 0.3); padding: 4px; border-radius: 4px;`
        });


        for (let x = 0; x <= gridSize; x += cellSize) {
            const xline = board.create('line', [[0 - 0.5 * cellSize, x - 0.5 * cellSize], [gridSize - 0.5 * cellSize, x - 0.5 * cellSize]], { straightFirst: false, straightLast: false, strokeWidth: 1, color: 'grey' })
            const yline = board.create('line', [[x - 0.5 * cellSize, 0 - 0.5 * cellSize], [x - 0.5 * cellSize, gridSize - 0.5 * cellSize]], { straightFirst: false, straightLast: false, strokeWidth: 1, color: 'grey' })

        }


        board.on('down', function (e) {
            if (hasStarted || foodBits.length >= 50) return;
            const coords = board.getUsrCoordsOfMouse(e);
            const x = coords[0];
            const y = coords[1];

            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) {
                console.log("click out of bounds");
                return;
            }
            createFood(x, y);
            board.unsuspendUpdate();
        });

        function createIndividual(x, y) {
            const key = `${x},${y}`;
            if (!occupied.has(key)) {
                occupied.add(key);
                const individual = board.create('point', [x, y], { color: aliveColor, size: 4, fixed: true, showInfobox: false, name: '' });
                individual.dead = false;
                individual.bitsEaten = 0;
                individual.stepsSinceFood = 0;
                individuals.push(individual);
            }
        }
        function createFood(x, y) {
            const key = `${x},${y}`;
            if (!occupiedFood.has(key)) {
                occupiedFood.add(key);
                const point = board.create('point', [x, y], { color: 'green', size: 2, fixed: true, showInfobox: false, name: '' });

                foodBits.push(point);
            }
        }

        function getOffspringPosition(oldX, oldY) {

            const deltaX = (Math.random() > 0.5) ? -1 : 1;
            const deltaY = (Math.random() > 0.5) ? -1 : 1;
            let newX = oldX;
            let newY = oldY;
            const rand = Math.random();

            if (rand < 0.33) {
                newX += deltaX * 0.5;
            }
            else if (rand < 0.66) {
                newY += deltaY * 0.5;
            }
            else {
                newX += deltaX * 0.5;
                newY += deltaY * 0.5;
            }

            const posObject = { x: newX, y: newY };
            return posObject;
        }

        function kill(ind, i) {
            console.log("killing ind", ind)
            board.removeObject(ind);
            individuals.splice(i)


        }

        function reproduce(ind) {
            const newPos = getOffspringPosition(ind.X(), ind.Y());
            if (newPos.x > 0 && newPos.x < 20 && newPos.y > 0 && newPos.y < 20) {
                createIndividual(newPos.x, newPos.y);
            }
        }

        function getRandomBetween(min, max) {
            return Math.random() * (max - min) + min;
        }

        function checkReproduction() {
            individuals.forEach(ind => {
                if (ind.bitsEaten >= 5) {
                    reproduce(ind);
                    ind.bitsEaten = 0;
                }
            })
        }
        function checkDeaths() {
            individuals.forEach((ind, index)=> {
                if (ind.stepsSinceFood >= 10) {
                    ind.setAttribute({color: 'black'});
                    kill(ind, index);
                    board.update();
                    
                
                }
                else if (ind.stepsSinceFood >= 7) {
                    ind.setAttribute({color: 'darkgreen'});
                
                }
                else if (ind.stepsSinceFood < 7){
                    ind.setAttribute({color: aliveColor});
                }
                
            })
        }


        function step() {
            //hasStarted = true;
            stepCounter++;
            findNearestFood();
            checkReproduction();
            checkDeaths();
            board.update();

        }

        const lines = [];
        function findNearestFood() {
            //reset lines
            lines.forEach(line => board.removeObject(line));
            lines.length = 0;

            for (let i = 0; i < individuals.length; i++) {
                //if (ind.dead) return;
                let minDistance = Infinity;
                let closestIndex = -1;

                for (let j = 0; j < foodBits.length; j++) {
                    const dx = foodBits[j].X() - individuals[i].X();
                    const dy = foodBits[j].Y() - individuals[i].Y();
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < minDistance) {
                        minDistance = dist;
                        closestIndex = j;
                    }
                }

                if (closestIndex !== -1) {
                    const ind = individuals[i];
                    const food = foodBits[closestIndex];

                    // (draw line to show "focus")
                    const line = board.create('line', [ind, food], {
                        straightFirst: false,
                        straightLast: false,
                        strokeColor: '#888',
                        strokeWidth: 1
                    });
                    lines.push(line);

                    const dx = food.X() - ind.X();
                    const dy = food.Y() - ind.Y();
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    console.log(ind.stepsSinceFood)

                    if (dist > 1) {
                        // move 1 unit toward the food
                        const nx = ind.X() + (dx / dist);
                        const ny = ind.Y() + (dy / dist);
                        ind.moveTo([nx, ny]);
                        ind.stepsSinceFood++;
                    } else {
                        ind.moveTo([food.X(), food.Y()]);
                        ind.bitsEaten++;
                        ind.stepsSinceFood=0;
                        board.removeObject(food);
                        foodBits.splice(closestIndex, 1);
                    }
                }
            }
        }



        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function tenStep() {
            for (let i = 0; i < 10; i++) {
                step();
                if (droughtActive) {
                    await sleep(1000);
                }
                await sleep(100); // Delay 100ms between steps
            }

        }


        function reset() {
            hasStarted = false;
            stepCounter = 0;
            droughtActive = false;

            board.suspendUpdate();

            individuals.forEach(obj => board.removeObject(obj));
            occupied.clear();
            individuals.length = 0;

            createIndividual(startX, startY);
            board.unsuspendUpdate();
        }


        createIndividual(startX, startY);


    </script>

</body>

</html>