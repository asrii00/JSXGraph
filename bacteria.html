<!DOCTYPE html>
<html>

<head>
    <title>JSXGraph Example</title>
    <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
    <style>
        #box {
            width: 900px;
            height: 600px;
        }

        div {
            margin: 7px;
        }
    </style>
</head>

<body>
    <div id="box" class="jxgbox"></div>
    <div class="flex">
        <button onClick="step()"> Step </button>
        <button onClick="hundredStep()"> 100 steps </button>
        <button onClick="add50food()"> Lisää 50 ravintopistettä </button>
        <button onClick="reset()"> Reset </button>
    </div>



    <script>

        const board = JXG.JSXGraph.initBoard('box', {
            boundingbox: [-1, 21, 31, -1],
            axis: true,
            showCopyright: false,
            showNavigation: false
        });

        const gridSize = 20;
        const cellSize = 0.5;

        const mutationChance = 0.33;
        const maxFood = 100;

        const startX = 9.5;
        const startY = 10.5;

        let individuals = [];
        const foodBits = [];
        const lines = [];

        const occupied = new Set(); //needs grid to work so not utilized atm
        const occupiedFood = new Set();

        let hasStarted = false;
        let stepCounter = 0;

        const aliveColor = "#68C93E";
        const deadFromDrought = "#6D5F3E";


        //const s0 = board.create('slider', [[21, 5], [25, 5], [0, 0.33, 1]], { name: 'Altitude preference' });

        const stepLabel = board.create('text', [21, 19.5, function () {
            return 'Current timestep: ' + stepCounter;
        }], {
            anchorX: 'left',
            anchorY: 'top',
            fontSize: 20,
            fixed: true,
            highlight: false,
            cssStyle: `background-color: rgba(111, 163, 230, 0.3); padding: 4px; border-radius: 4px;`
        });


        for (let x = 0; x <= gridSize; x += cellSize) {
            const xline = board.create('line', [[0 - 0.5 * cellSize, x - 0.5 * cellSize], [gridSize - 0.5 * cellSize, x - 0.5 * cellSize]], { straightFirst: false, straightLast: false, strokeWidth: 1, color: 'grey' })
            const yline = board.create('line', [[x - 0.5 * cellSize, 0 - 0.5 * cellSize], [x - 0.5 * cellSize, gridSize - 0.5 * cellSize]], { straightFirst: false, straightLast: false, strokeWidth: 1, color: 'grey' })
        }


        board.on('down', function (e) {
            if (hasStarted || foodBits.length >= 50) return;
            const coords = board.getUsrCoordsOfMouse(e);
            const x = coords[0];
            const y = coords[1];

            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) {
                console.log("click out of bounds");
                return;
            }
            createFood(x, y);
            board.unsuspendUpdate();
        });

        function getMutatedSpeedMult() {
            const rand = Math.random() + 0.5;
            return rand;
        }

        function valueToHexColor(value) {
            // Clamp value between 0 and 1
            value = Math.max(0, Math.min(1, value));

            let r, g, b = 0;

            if (value < 0.5) {
                r = 255;
                g = Math.round(510 * value);  // from 0 to 255
            } else {
                r = Math.round(510 * (1 - value));  // from 255 to 0
                g = 255;
            }

            // Helper to convert to two-digit hex
            const toHex = c => c.toString(16).padStart(2, '0');

            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }



        function createIndividual(x, y, parentMult, starter = true) {
            const key = `${x},${y}`;
            if (!occupied.has(key)) {
                occupied.add(key);
                const individual = board.create('point', [x, y], { color: aliveColor, size: 4, fixed: true, showInfobox: false, name: '' });
                individual.dead = false;
                individual.bitsEaten = 0;
                individual.stepsSinceFood = 0;
                individual.speedMult = Number(parentMult);
                if (!starter && Math.random() < mutationChance) {
                    individual.speedMult *= getMutatedSpeedMult();
                    individual.speedMult = Math.min(individual.speedMult, 1);
                }
                const str = individual.speedMult.toFixed(2);
                individual.setAttribute({ name: str, color: valueToHexColor(individual.speedMult) })
                individuals.push(individual);
            }
            board.update();
        }
        function createFood(x, y) {
            const key = `${x},${y}`;
            if (!occupiedFood.has(key)) {
                occupiedFood.add(key);
                const point = board.create('point', [x, y], { color: 'green', size: 2, fixed: true, showInfobox: false, name: '' });

                foodBits.push(point);
            }
        }

        function getOffspringPosition(oldX, oldY) {

            const deltaX = (Math.random() > 0.5) ? -1 : 1;
            const deltaY = (Math.random() > 0.5) ? -1 : 1;
            let newX = oldX;
            let newY = oldY;
            const rand = Math.random();

            if (rand < 0.33) {
                newX += deltaX * 0.5;
            }
            else if (rand < 0.66) {
                newY += deltaY * 0.5;
            }
            else {
                newX += deltaX * 0.5;
                newY += deltaY * 0.5;
            }

            const posObject = { x: newX, y: newY };
            return posObject;
        }

        function kill(ind, index) {
            if (ind.dead) return;

            ind.dead = true;
            board.removeObject(ind);
            individuals.splice(index, 1);

            // remove lines if any
            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].point1 === ind || lines[i].point2 === ind) {
                    board.removeObject(lines[i]);
                    lines.splice(i, 1);
                }
            }
        }

        function reproduce(ind) {
            const newPos = getOffspringPosition(ind.X(), ind.Y());
            if (newPos.x > 0 && newPos.x < 20 && newPos.y > 0 && newPos.y < 20) {
                createIndividual(newPos.x, newPos.y, ind.speedMult, false);
            }
        }

        function getRandomBetween(min, max) {
            return Math.random() * (max - min) + min;
        }

        function checkReproduction() {
            individuals.forEach(ind => {
                if (ind.bitsEaten >= 5) {
                    reproduce(ind);
                    ind.bitsEaten = 0;
                }
            })
        }
        function checkDeaths() {
            const toKill = [];

            individuals.forEach((ind, index) => {
                if (ind.stepsSinceFood >= 40) {
                    toKill.push(index);
                } else if (ind.stepsSinceFood >= 32) {
                    ind.setAttribute({ opacity: 0.4 });
                } else {
                    ind.setAttribute({ opacity: 1 });
                }
            });

            // remove in reverse order to avoid index issues
            toKill.reverse().forEach(index => {
                kill(individuals[index], index);
            });
        }


        function step() {
            //hasStarted = true;
            if (foodBits.length > 0) {
                board.suspendUpdate();
                stepCounter++;
                findNearestFood();
                checkReproduction();
                checkDeaths();
                board.unsuspendUpdate();
            }
        }

        async function findNearestFood() {
            //reset lines
            lines.forEach(line => board.removeObject(line));
            lines.length = 0;

            for (let i = 0; i < individuals.length; i++) {
                let minDistance = Infinity;
                let closestIndex = -1;

                for (let j = 0; j < foodBits.length; j++) {
                    const dx = foodBits[j].X() - individuals[i].X();
                    const dy = foodBits[j].Y() - individuals[i].Y();
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < minDistance) {
                        minDistance = dist;
                        closestIndex = j;
                    }
                }

                if (closestIndex !== -1) {
                    const ind = individuals[i];
                    const food = foodBits[closestIndex];

                    // (draw line to show "focus")
                    const line = board.create('line', [ind, food], {
                        straightFirst: false,
                        straightLast: false,
                        strokeColor: '#888',
                        strokeWidth: 1
                    });
                    lines.push(line);

                    const dx = food.X() - ind.X();
                    const dy = food.Y() - ind.Y();
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 1) {
                        // move toward the food
                        const nx = ind.X() + (dx / dist) * ind.speedMult;
                        const ny = ind.Y() + (dy / dist) * ind.speedMult;
                        ind.moveTo([nx, ny], 50);

                        ind.stepsSinceFood++;
                    } else {
                        ind.moveTo([food.X(), food.Y()], 50);

                        ind.bitsEaten++;
                        ind.stepsSinceFood = 0;
                        board.removeObject(food);
                        foodBits.splice(closestIndex, 1);
                    }
                }
            }
        }


        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function add50food() {
            const foodToAdd = Math.min(50, maxFood - foodBits.length);
            console.log(foodBits.length, "adding: ", foodToAdd)

            for (let i = 0; i < foodToAdd; i++) {
                const randX = getRandomBetween(0.5, 19.5);
                const randY = getRandomBetween(0.5, 19.5);
                createFood(randX, randY);
            }
        }

        let autoStepping = false;
        async function hundredStep() {
            if (!autoStepping) {
                autoStepping = true;
                for (let i = 0; i < 100; i++) {
                    step();
                    await sleep(50); // Delay 100ms between steps
                }
                autoStepping = false;
            }
        }


        function reset() {
            hasStarted = false;
            stepCounter = 0;
            autoStepping = false;

            board.suspendUpdate();

            individuals.forEach(obj => board.removeObject(obj));
            foodBits.forEach(obj => board.removeObject(obj));
            lines.forEach(obj => board.removeObject(obj));

            individuals.length = 0;
            foodBits.length = 0;
            lines.length = 0;
            occupied.clear();
            occupiedFood.clear();

            createIndividual(startX, startY, 0.25);

            board.unsuspendUpdate();
        }


        createIndividual(startX, startY, 0.25);


    </script>

</body>

</html>