<!DOCTYPE html>
<html>

<head>
    <title>Shelttidataa</title>
    <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
    <style>
        #box {
            width: 1200px;
            height: 500px;
        }

        #box2 {
            width: 300px;
            height: 400px;
        }

        #box3 {
            width: 800px;
            height: 400px;
        }

        div {
            margin: 8px;
            max-width: 1200px;
        }

        #flex {
            display: flex;
            width: 1800px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 600px;
            margin: 0px;
        }

        .controls label {
            white-space: nowrap;
        }
    </style>
</head>

<body>
    <h3>Shetlanninlammaskoirien luonteenpiirteet (n=216)</h3>
    <div class="controls">
        <label><input type="radio" name="sex" value="females" checked> Nartut</label>
        <label><input type="radio" name="sex" value="males"> Urokset</label>
        <label><input type="radio" name="sex" value="both"> Molemmat</label>

    </div>

    <div id="box"></div>
    <div> Taulukko 1. Skaalalla 1-5 arvioidut luonteenpiirteet. Punainen piste kuvaa keskiarvoa. <br> <br></div>
    <div id='flex'>
        <div id="box2" style="margin-right: 50px;"></div>
        <div id="box3"></div>

    </div>
    <div id="flex">
        <div style="width: 300px;margin-right: 50px;">
            Taulukko 2. Shelttien paino jaoteltuna sukupuolen mukaan. <br><br>

        </div>
        <div style="width: 800px;">
            Taulukko 3. Shelttien elämäntyyli. <br><br>

        </div>
    </div>
    <div> Tehtäviä:<br>
        1. Kuvaile tyypillistä shetlanninlammaskoiraa. Mainitse ainakin 6 luonteenpiirrettä, jotka ovat tässä rodussa erityisen yleisiä (//vahvoja) tai harvinaisia (//heikkoja).<br>
        2. Onko shelttien luonteenpiirteissä paljon vaihtelua? Minkä luonteenpiirteen suhteen shetlanninlammaskoirat vaikuttavat erityisen yhtenäisiltä?<br>
        3. Onko narttujen ja urosten välillä eroa? <br>
        4. Millainen on tyypillisen sheltin "elämäntapa" ulkoilun, harrastusten ja yksinolon määrän osalta?<br>
        5. Pekka haluaa rauhallisen, hiljaisen ja tottelevaisen koiran, joka ei ole pelokas eikä epävarma. Kannattaako hänen ottaa shetlanninlammaskoira? Miksi/miksi ei?<br>
        6. Maija haluaa tottelevaisen, oppimishaluisen ja ei-aggressiivisen koiran. Kannattaako hänen ottaa shetlanninlammaskoira? Miksi/miksi ei? <br>
        7. Jos Maija ottaa shetlanninlammaskoiran, 
        suosittelisitko hänelle narttu- vai urospentua, vai onko sukupuolella väliä?<br><br>

        <a href="https://figshare.com/articles/dataset/Salonen_et_al_Reliability_and_Validity_of_a_Dog_Personality_and_Unwanted_Behavior_Survey/14479152/1?file=27715521">Datan lähde</a>
        

    </div>



    <script src="sheltie_data.js"></script>
    <script>
        //TODO: regenerate data to exclude puppies
        //TODO: don't reload all data every time
        const board = JXG.JSXGraph.initBoard('box', {
            boundingbox: [-10, 5.5, 100, -0.75],
            axis: true,
            withLabel: false,
            showNavigation: false,
            showCopyright: false,
            defaultAxes: {
                x: {
                    ticks: {
                        ticksDistance: 250,  //hide ticks
                        minorTicks: 0,
                        drawLabels: false, //hide numbers along x axis
                        majorHeight: 0 //hide vertical grid lines
                    }
                }
            }
        });


        const traits = [
            "Playful_dogs",
            "Anxious",
            "Fearful_dogs",
            "Impulsive",
            "avg_aggression",
            "Erratic",
            "Obedient",
            "Calm",
            "Insecure",
            "Prey_driven_chase",
            "Energetic",
            "Provocative",
            "Active",
            "Vocal",
            "Willing_to_learn"
        ];
        const labels = [
            "Leikkisä",
            "Ahdistunut",
            "Pelokas",
            "Impulsiivinen",
            "Aggressiivinen",
            "Arvaamaton",
            "Tottelevainen",
            "Rauhallinen",
            "Epävarma",
            "Jahtiviettinen",
            "Energinen",
            "Provosoiva",
            "Aktiivinen",
            "Äänekäs",
            "Oppimishaluinen"
        ];

        const bins = traits.map(trait => ({
            trait,
            values: []
        }));

        const data = sheltieData;
        const boxWidth = 3;
        board.create('text', [-5, 3, 'Arvio'], { fontSize: 14, anchorX: 'middle', anchorY: 'middle', rotate: -90 });
        board.create('text', [45, -0.5, 'Luonteenpiirre'], { anchorX: 'middle', anchorY: 'middle' });

        let points = [];
        let weights = [];
        let femaleWeights = [];
        let maleWeights = [];

        const categoricalFields = [
            "daily_exercise",
            "hobby_frequency_home",
            "hobby_frequency_out",
            "alone_time"
        ];

        let categoricalCounts = {};

        function quantiles(arr) {
            const sorted = arr.slice().sort((a, b) => a - b);
            const q = p => {
                const pos = (sorted.length - 1) * p;
                const base = Math.floor(pos);
                const rest = pos - base;
                if (sorted[base + 1] !== undefined) {
                    return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
                } else {
                    return sorted[base];
                }
            };
            return {
                min: sorted[0],
                q1: q(0.25),
                median: q(0.5),
                q3: q(0.75),
                max: sorted[sorted.length - 1]
            };
        }

        function plotData() {
            board.suspendUpdate();

            // reset
            for (const obj of points) board.removeObject(obj);
            points = [];
            for (const bin of bins) {
                bin.values = [];
            }
            femaleWeights = [];
            maleWeights = [];
            weights = [];
            categoricalCounts = {};

            const selectedSex = document.querySelector('input[name="sex"]:checked').value;

            let filteredFemales = data.filter(dog => dog.sex === 'female');
            for (const dog of filteredFemales) {
                const val = dog.weight;
                if (typeof val === 'number') {
                    femaleWeights.push(val);
                }
            }

            let filteredMales = data.filter(dog => dog.sex === 'male');
            for (const dog of filteredMales) {
                const val = dog.weight;
                if (typeof val === 'number') {
                    maleWeights.push(val);
                }
            }

            weights = [...femaleWeights, ...maleWeights];

            let filteredDogs = data;
            if (selectedSex === 'females') {
                filteredDogs = filteredFemales;
            } else if (selectedSex === 'males') {
                filteredDogs = filteredMales;
            }
    
            for (const dog of filteredDogs) {
                for (const bin of bins) {
                    const val = dog[bin.trait];
                    if (typeof val === 'number') {
                        bin.values.push(val);
                    }
                }
            }

            for (const field of categoricalFields) {
                categoricalCounts[field] = {};
            }

            for (const dog of filteredDogs) {
                for (const field of categoricalFields) {
                    const value = dog[field];
                    if (!value) continue;

                    if (!categoricalCounts[field][value]) {
                        categoricalCounts[field][value] = 0;
                    }
                    categoricalCounts[field][value]++;
                }
            }

            for (let i = 0; i < bins.length; i++) {
                const bin = bins[i];
                const x = i * 6 + 5; // bin center
                if (bin.values.length < 3) continue;

                const q = quantiles(bin.values);
                const sum = bin.values.reduce((a, b) => a + b, 0);
                const mean = sum / bin.values.length;

                const box = board.create('polygon', [
                    [x - boxWidth / 2, q.q1],
                    [x + boxWidth / 2, q.q1],
                    [x + boxWidth / 2, q.q3],
                    [x - boxWidth / 2, q.q3]
                ], {
                    fillColor: 'lightblue',
                    strokeColor: 'blue',
                    fillOpacity: 0.5,
                    fixed: true,
                    vertices: { visible: false }
                });

                const median = board.create('line', [
                    [x - boxWidth / 2, q.median],
                    [x + boxWidth / 2, q.median]
                ], {
                    straightFirst: false,
                    straightLast: false,
                    strokeColor: 'black',
                    fixed: true
                });

                const whiskerLow = board.create('line', [
                    [x, q.min],
                    [x, q.q1]
                ], {
                    strokeColor: 'blue',
                    fixed: true,
                    straightFirst: false,
                    straightLast: false
                });

                const whiskerHigh = board.create('line', [
                    [x, q.q3],
                    [x, q.max]
                ], {
                    strokeColor: 'blue',
                    fixed: true,
                    straightFirst: false,
                    straightLast: false
                });

                const meanDot = board.create('point', [x, mean], {
                    size: 2,
                    color: 'red',
                    fixed: true,
                    name: '',
                    showInfobox: false
                });

                const label = board.create('text', [x, -0.2, `${labels[i]}`], {
                    anchorX: 'middle',
                    anchorY: 'top',
                    fixed: true,
                    fontSize: 10,
                    color: 'grey'
                });
                points.push(box, median, whiskerLow, whiskerHigh, meanDot);
            }

            board.unsuspendUpdate();
        }


        plotData()

        console.log(categoricalCounts)
        document.querySelectorAll('input[name="sex"]').forEach(radio => {
            radio.addEventListener('change', plotData);
        });

        ////////////////////////////////////////////////////

        const board2 = JXG.JSXGraph.initBoard('box2', {
            boundingbox: [-5, 22, 15, -0.75],
            axis: true,
            withLabel: false,
            showNavigation: false,
            showCopyright: false,
            defaultAxes: {
                x: {
                    ticks: {
                        ticksDistance: 250,  //hide ticks
                        minorTicks: 0,
                        drawLabels: false, //hide numbers along x axis
                        majorHeight: 0 //hide vertical grid lines
                    }
                }
            }
        });


        femaleWeights.forEach(value => {
            const dot = board2.create('point', [5, value], {
                size: 2,
                color: 'red',
                fixed: true,
                name: '',
                showInfobox: false,
                opacity: 0.3
            });
        });
        maleWeights.forEach(value => {
            const dot = board2.create('point', [10, value], {
                size: 2,
                color: 'blue',
                fixed: true,
                name: '',
                showInfobox: false,
                opacity: 0.3
            });
        });

        board2.create('text', [5, -0.5, 'Nartut'], { anchorX: 'middle', anchorY: 'middle' });
        board2.create('text', [10, -0.5, 'Urokset'], { anchorX: 'middle', anchorY: 'middle' });
        board2.create('text', [-3, 11, 'Paino (kg)'], { anchorX: 'middle', anchorY: 'middle', rotate: -90 });

        ///////////////////////////////////////////////////////
        const board3 = JXG.JSXGraph.initBoard('box3', {
            boundingbox: [-30, 15, 30, -15],
            axis: false,
            withLabel: false,
            showNavigation: false,
            showCopyright: false,
        });

        const exerciseLabels = {
            "under_1_hour": "Alle tunti",
            "1-2_hours": "1–2 tuntia",
            "2-3_hours": "2–3 tuntia",
            "over_3_hours": "Yli 3 tuntia"
        };

        const hobbyHomeLabels = {
            "never_no_hobby": "Ei koskaan",
            "infrequent": "Harvoin",
            "active": "Säännöllisesti"
        };

        const hobbyOutLabels = {
            "never_no_hobby": "Ei koskaan",
            "infrequent": "Harvoin",
            "active": "Säännöllisesti"
        };

        const aloneTimeLabels = {
            "under_1_hour": "Alle tunti",
            "1-3_hours": "1–3 tuntia",
            "3-6_hours": "3–6 tuntia",
            "6-8_hours": "6–8 tuntia",
            "over_8_hours": "Yli 8 tuntia"
        };

        const exerciseValues = Object.values(categoricalCounts.daily_exercise);
        const exerciseKeys = Object.keys(categoricalCounts.daily_exercise);

        const hobbyInValues = Object.values(categoricalCounts.hobby_frequency_home);
        const hobbyInKeys = Object.keys(categoricalCounts.hobby_frequency_home);

        const hobbyOutValues = Object.values(categoricalCounts.hobby_frequency_out);
        const hobbyOutKeys = Object.keys(categoricalCounts.hobby_frequency_out);

        const aloneValues = Object.values(categoricalCounts.alone_time);
        const aloneKeys = Object.keys(categoricalCounts.alone_time);

        // translate
        const exerciseTranslatedLabels = exerciseKeys.map(k => exerciseLabels[k] ?? k);
        const hobbyInTranslatedLabels = hobbyInKeys.map(k => hobbyHomeLabels[k] ?? k);
        const hobbyOutTranslatedLabels = hobbyOutKeys.map(k => hobbyOutLabels[k] ?? k);
        const aloneTranslatedLabels = aloneKeys.map(k => aloneTimeLabels[k] ?? k);


        const xPositions = [
            { x: -22.5, array: exerciseValues, label: 'Liikunta (tuntia päivässä)', labels: exerciseTranslatedLabels },
            { x: -7.5, array: hobbyInValues, label: 'Harrastaminen kotona', labels: hobbyInTranslatedLabels },
            { x: 7.5, array: hobbyOutValues, label: 'Harrastaminen muualla', labels: hobbyOutTranslatedLabels },
            { x: 22.5, array: aloneValues, label: 'Yksinolo (tuntia päivässä)', labels: aloneTranslatedLabels }
        ];

        for (const item of xPositions) {
            const pie = board3.create('chart', [item.array], {
                chartStyle: 'pie',
                colors: ['#ff9999', '#66b3ff', '#99ff99', '#ffcc99', '#cc99ff', '#ffb366'],
                center: [item.x, 0],
                radius: 5,
                strokeColor: '#000'
            });

            board3.create('text', [item.x, -10, item.label], { anchorX: 'middle', fontSize: 14 });

            let angle = 0;
            const total = item.array.reduce((a, b) => a + b, 0);

            item.array.forEach((value, i) => {
                const midAngle = angle + (value / total) * Math.PI;
                const labelX = item.x + 6 * Math.cos(midAngle);
                const labelY = 6 * Math.sin(midAngle);
                board3.create('text', [labelX, labelY, item.labels[i]], {
                    anchorX: 'middle',
                    anchorY: 'middle',
                    fontSize: 12
                });
                angle += (value / total) * 2 * Math.PI;
            });
        }

    </script>


</body>

</html>