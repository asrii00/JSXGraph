<!DOCTYPE html>
<html lang="en">

</html>

<head>
    <title>JSXGraph Example</title>
    <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
    <style>
        #box {
            width: 1000px;
            height: 600px;
        }

        div {
            margin: 10px;
            width: 1000px;
        }
    </style>
</head>

<body>
    <div id="box" class="jxgbox"></div>
    <div>
        <button onclick="pair()">Muodosta parit</button>
        <button onclick="generateOffspring()">Generoi jälkeläiset</button>
        <button onclick="moveToNextGen()">Siirry seuraavaan sukupolveen</button>
        <button onclick="TwentyGens()">20 sukupolvea</button>
        <button id="toggleBtn">Laita valintapaine päälle</button>

    </div>
    <div>
        <b>Tehtävät:</b>
        Lue teksti <i>Merletekijä: Värigeenin haitallinen puoli</i> ja vastaa sitten kysymyksiin.<br>
        1. Jos kaksi tavallista merle-koiraa (Mm x Mm) risteytyy, millä todennäköisyydellä yksittäinen pentu on
        kaksoismerle (MM)? <br>
        2. Populaatiossa on aluksi 48 ei-merleä ja 12 tavallista merleä. Jos yksilöt liittyvät pareiksi satunnaisesti,
        millä todennäköisyydellä muodostuu vähintään yksi merle x merle-pari? (Vinkki: käytä komplementtisääntöä,
        Poisson-aproksimaatiota) //vähän hankala laskea. <br>
        TAI: Arvioi kokeellisesti, millä todennäköisyydellä muodostuu vähintään yksi merle x merle -pari. Voit päivittää
        sivun ja painaa Muodosta parit -nappia uudelleen
        toistaaksesi "kokeen". Toista tämä vähintään kymmenen kertaa.<br>
        3. Jos merle x merle-parin muodostumisen todennäköisyys on X ja jokainen pari saa 2 pentua, millä
        todennäköisyydellä populaatiossa syntyy
        yhden sukupolven aikana vähintään yksi kaksoismerle-pentu? <br>
        4. Tutki kokeellisesti, kuinka usein esiintyy vähintään yksi kaksoismerle-pentu. Edistä simulaatiota vähintään
        10 sukupolven verran ja merkitse jokaisen
        sukupolven osalta muistiin, esiintyikö siinä yhtään kaksoismerle-pentua vai ei.

        <br> <br>
        <b>Satunnaisajautuminen (neutraalit tekijät) vs. luonnonvalinta</b><br>

        Satunnaisajautuminen on ilmiö, jossa sattuma vaikuttaa perinnöllisen ominaisuuden suhteelliseen esiintymiseen
        ajan kuluessa, vaikka mitään suuntaavaa luonnonvalintaa ei tapahtuisi.
        Kun simulaatio on ei valintapainetta-tilassa, kaksoismerle-yksilöille ei koidu mitään haittaa väristään - toisin
        kuin todellisuudessa, jossa kuurous ja sokeus vaikeuttaisi selvästi villin eläimen selviytymistä. Sen sijaan
        seuraavaan sukupolveen siirtyvät alleelit (kirjaimet) määräytyvät osin satunnaisesti - esimerkiksi kaksi
        Mm-yksilöä voivat satunnaisesti saada kaksi mm-jälkeläistä, jolloin niiden osalta merletekijä katoaa
        siirryttäessä seuraavaan sukupolveen.<br><br>

        1. Paina 20 sukupolvea -nappia, jolloin simulaatio edistyy 20 sukupolven ajan ja pysähtyy sitten. Laske
        värijakauma
        populaatiossa. Miten se eroaa alkuperäisestä (48 ei-merleä, 12 tavallista merleä)? Onko suhteellisissa
        jakaumissa merkittävää eroa?<br>
        Päivitä sivu ja aloita simulaatio alusta. Edistä sitä taas 20 sukupolven verran ja laske jakauma. Eroaako se
        edellisestä tuloksesta? Toista sama vielä kolmannen kerran ja tutki tuloksia. Kehittyykö populaation jakauma
        satunnaisesti eri suuntiin joka kerralla, eli voitko havaita satunnaisajautumista?<br>

        2. Laita valintapaine päälle napista. Tällöin kaksoismerle-väristä aiheutuu yksilölle merkittävää haittaa
        eivätkä tällaiset yksilöt selviä seuraavaan sukupolveen tai eivät pysty lisääntymään. Edistä simulaatiota 20
        sukupolven ajan ja laske lopuksi värijakauma populaatiossa. Mitä havaitset? Tapahtuiko värien osuuksissa muutos
        alkuperäiseen verrattuna? Voit myös toistaa saman “kokeen” useamman kerran aloittamalla simulaation alusta ja 
        tutkia, tapahtuuko sama ilmiö joka kerralla.
        <br>3. Mitä luulet, että todellisuudessa tapahtuisi, jos populaatio merle- ja ei-merlekoiria jätettäisiin oman
        onnensa nojaan selviytymään luonnossa, missä kuurous ja sokeus haittaisi merkittävästi koiran selviytymistä?
        Mitä se kertoo siitä, miten ihmisten huostassa olevat lemmikkipopulaatiot ja villit populaatiot saattavat erota
        toisistaan?

        <br><br>
        <b>Merletekijä: Värigeenin haitallinen puoli</b><br>

        Joissakin koiraroduissa esiintyvä merle- eli valkoisensekainen marmoroitu väritys on siitä erityinen, että jos
        koira perii merletekijän molemmilta vanhemmiltaan, se aiheuttaa tavallista valkovoittoisemman värityksen lisäksi
        huomattavia terveys- tai kehitysongelmia, kuten kuurosokeutta.<br> <br>

        Koira voi olla merlegeenin osalta yksi kolmesta alleeli- eli kirjainyhdistelmästä: MM (kaksoismerle), Mm
        (tavallinen merle) tai mm (ei merlekuviointia). Yksilö perii kummaltakin vanhemmaltaan yhden kirjaimen, joka
        valikoituu satunnaisesti, esimerkiksi Mm-vanhempi periyttää pennulleen 50% todennäköisyydellä M-kirjaimen ja 50%
        todennäköisyydellä m-kirjaimen. Kaksoismerlen terveyshaittojen vuoksi kahden tavallisen merlen risteyttäminen on
        kiellettyä, sillä on mahdollista, että osasta pennuista tulee kaksoismerlejä. Yksittäinen merletekijä (Mm) on
        harmiton. <br> <br>

        Koirien kasvattajat säätelevät koiriensa pariutumista, mutta tämä simulaatio kuvaa, mitä tapahtuisi, jos lauma
        koiria
        esimerkiksi villiintyisi ja pääsisi pariutumaan vapaasti ja värin suhteen täysin satunnaisesti. Mustat pallot
        (mm) kuvaavat koiria, joilla ei ole merletekijää.
        Harmaat pallot (Mm) kuvaavat tavallisia merle-koiria ja mahdolliset valkoiset pallot (MM) kaksoismerlejä.
        <br>
        <img style="margin-top: 10px"
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/33/BorderColliePupTheEye_wb.jpg/250px-BorderColliePupTheEye_wb.jpg">
        Tavallinen merle. <br>
        <img style="margin-top: 10px"
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/Aussie_double_merle.jpg/250px-Aussie_double_merle.jpg">
        Kaksoismerle. Kuvan koira on kuuro ja sillä on epänormaalisti kehittyneet silmät. <br><br>

        (Kuvat: Wikimedia, https://commons.wikimedia.org/wiki/File:BorderColliePupTheEye_wb.jpg,
        https://commons.wikimedia.org/wiki/File:Aussie_double_merle.jpg )



    </div>

    <script>

        // TODO: could add reset button
        const maxX = 100;
        const maxY = 60;

        const columns = 10;
        const xSpacing = 3.6;
        const ySpacing = 20;
        const xStart = 3.5;
        const yStart = 50;

        const genotypes = [
            { num: 48, color: 'black', label: 'mm' },
            { num: 12, color: 'grey', label: 'Mm' },
            { num: 0, color: 'white', label: 'MM' },
        ]

        const board = JXG.JSXGraph.initBoard('box', {
            boundingbox: [-3, maxY + 3, maxX + 3, -3],
            axis: false,
            showNavigation: false,
            showCopyright: false
        });

        const adultIndividuals = [];
        const pairedIndividuals = [];
        const nextGenIndividualsColors = [];
        const nextGen = [];

        let isPaired = false;
        let hasReproduced = false;

        let selectionPressureOn = false;
        let round = 0;

        function randomInt(min, max) {
            return Number(Math.floor(Math.random() * (max - min + 1)) + min);
        }

        function generatePopulation() {
            genotypes.forEach((genotype) => {
                for (i = 0; i < genotype.num; i++) {
                    const posX = randomInt(0, maxX);
                    const posY = randomInt(0, maxY);
                    const circle = board.create('point', [posX, posY], { size: 9, fillColor: genotype.color, strokeColor: 'black', strokeWidth: 1, name: genotype.label, fixed: true });
                    circle.customState = genotype.color;
                    adultIndividuals.push(circle);
                }
            })
        }

        function popRandom(array) {
            if (array.length === 0) return null;
            const randomIndex = randomInt(0, array.length - 1);
            return array.splice(randomIndex, 1)[0]; //index of where to remove items, how many items to remove, [0] because it returns an array and we want the object in it
        }


        function pair() {
            if (isPaired) return;
            isPaired = true;

            while (adultIndividuals.length >= 2) {
                const popped1 = popRandom(adultIndividuals);
                const popped2 = popRandom(adultIndividuals);
                pairedIndividuals.push([popped1, popped2]);
            }
            //remove any unpaired individuals
            adultIndividuals.forEach((point) => {
                board.removeObject(point);
            });
            adultIndividuals.length = 0;
            moveToPairs(pairedIndividuals);
        }

        function moveToPairs(array) {
            array.forEach((pair, i) => {
                const row = Math.floor(i / columns);
                const col = i % columns;

                const y = yStart - row * ySpacing;
                const x1 = xStart + col * xSpacing * 2.75;   // left individual in pair
                const x2 = x1 + xSpacing;                // right individual in pair

                pair[0].moveTo([x1, y], 1000);
                pair[1].moveTo([x2, y], 1000);

                board.create('line', [pair[0], pair[1]], {
                    straightFirst: false,
                    straightLast: false,
                    strokeColor: 'gray',
                    opacity: 0.4
                });
            });

        }

        function getAllele(genotype) {
            switch (genotype) {
                case 'black':
                    return 'black';
                case 'grey':
                    return (Math.random() <= 0.5) ? 'black' : 'white';
                case 'white':
                    return 'white';
                default:
                    console.log('error in allele switch case')
                    return 'white';
            }
        }

        function combineAlleles(allele1, allele2) {
            if (allele1 == allele2) {
                return allele1;
            }
            else {
                return 'grey';
            }
        }

        function getGenotypeLabel(color) {
            switch (color) {
                case 'black':
                    return 'mm';
                case 'grey':
                    return 'Mm';
                case 'white':
                    return 'MM';
                default:
                    console.log("error in getgenolabel")
                    return '?';
            }
        }

        function drawInPairs(array) {
            array.forEach((pair, i) => {
                const row = Math.floor(i / columns);
                const col = i % columns;

                const y = yStart - row * ySpacing - 5;
                const x1 = xStart + col * xSpacing * 2.75;   // left individual in pair
                const x2 = x1 + xSpacing;                // right individual in pair

                child1Geno = getGenotypeLabel(pair[0]);
                child2Geno = getGenotypeLabel(pair[1]);

                const child1 = board.create('point', [x1, y], { size: 6, fillColor: pair[0], strokeColor: 'black', strokeWidth: 1, name: child1Geno, fixed: true })
                child1.customState = pair[0];
                const child2 = board.create('point', [x2, y], { size: 6, fillColor: pair[1], strokeColor: 'black', strokeWidth: 1, name: child2Geno, fixed: true })
                child2.customState = pair[1];
                nextGen.push(child1, child2);
            });
        }

        function generateOffspring() {
            if (!isPaired) return;
            if (hasReproduced) return;
            round++;
            roundLabel.setText('Sukupolvi ' + round.toFixed(0));
            hasReproduced = true;

            pairedIndividuals.forEach((pair, i) => {
                const parent1Allele1 = getAllele(pair[0].customState)
                const parent2Allele1 = getAllele(pair[1].customState)
                const childColor1 = combineAlleles(parent1Allele1, parent2Allele1);

                const parent1Allele2 = getAllele(pair[0].customState)
                const parent2Allele2 = getAllele(pair[1].customState)
                const childColor2 = combineAlleles(parent1Allele2, parent2Allele2);

                nextGenIndividualsColors.push([childColor1, childColor2]);
            })
            drawInPairs(nextGenIndividualsColors);
        }

        function scatterDraw() {
            adultIndividuals.forEach((point, i) => {
                point.setAttribute({ size: 9 })
                const posX = randomInt(0, maxX);
                const posY = randomInt(0, maxY);
                point.moveTo([posX, posY], 1000)
            })

        }
        function removeDoubleMerles() {
            const newArray = adultIndividuals.filter(pt => {
                if (pt.customState === "white") {
                    board.removeObject(pt);  // remove from board
                    return false;            // exclude from the new array
                }
                return true;               // keep if not white
            });
            return newArray;

        }

        function moveToNextGen() {
            if (isPaired && hasReproduced) {
                isPaired = false;
                pairedIndividuals.forEach((pair) => {
                    board.removeObject(pair[0]);
                    board.removeObject(pair[1]);
                });
                pairedIndividuals.length = 0;
                adultIndividuals.length = 0;
                nextGenIndividualsColors.length = 0;
                adultIndividuals.push(...nextGen);
                nextGen.length = 0;
                scatterDraw(adultIndividuals);
                if (selectionPressureOn) {
                    const newAdultIndividuals = removeDoubleMerles();
                    adultIndividuals.length = 0;
                    adultIndividuals.push(...newAdultIndividuals);
                }
                hasReproduced = false;
            }

        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function TwentyGens() {
            for (i = 0; i < 20; i++){
            pair();
            await sleep(1200);
            generateOffspring();
            await sleep(1500);
            moveToNextGen();
            await sleep(1500);
        }
        }

        const pressureLabel = board.create('text', [0, 0, 'Valintapaine päällä'], {
            anchorX: 'left',
            anchorY: 'top',
            fontSize: 16,
            fixed: true,
            highlight: false,
            visible: false
        });
        const roundLabel = board.create('text', [92, 0, 'Sukupolvi 0'], {
            anchorX: 'left',
            anchorY: 'top',
            fontSize: 16,
            fixed: true,
            highlight: false,
        });

        document.getElementById('toggleBtn').addEventListener('click', () => {
            selectionPressureOn = !selectionPressureOn;
            pressureLabel.setAttribute({ visible: selectionPressureOn });
            board.update();
            document.getElementById('toggleBtn').textContent = selectionPressureOn ? "Poista valintapaine" : "Laita valintapaine päälle";
        });
        
        generatePopulation();


    </script>

</body>

</html>