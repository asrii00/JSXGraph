<!DOCTYPE html>
<html>

<head>
    <title>JSXGraph Example</title>
    <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
    <style>
        #box {
            width: 1000px;
            height: 600px;
        }

        .text-with-bg {
            background-color: white;
            padding: 4px 6px;
            border-radius: 4px;
            transform: translateX(-8px);
        }

        #textbox {
            width: 1000px;
        }

        #flex {
            display: flexbox;
        }

        div {
            margin: 8px;
        }

        .jsx-text {
            background-color: #333;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: sans-serif;
            user-select: none;
            transform: translateX(-8px);
        }

        .jsx-button {
            background-color: #333;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: sans-serif;
            user-select: none;
            transform: translateX(-8px);
        }

        .jsx-button:hover {
            background-color: #444;
        }
    </style>
</head>

<body>

    <div id="box" class="jxgbox"></div>
    <div id="flex">
        <button onclick="stage1()">Vaihe 1</button>
        <button onclick="stage2a()">Vaihe 2a</button>
        <button onclick="stage2b()">Vaihe 2b</button>
        <button onclick="stage3()">Vaihe 3</button>
        <button onclick="stage4()">Vaihe 4</button>
        <button onclick="stage5()">Vaihe 5</button>
    </div>

    <div id="textbox">
        <br>
        <!-- 1. Vasemmalla oleva alue kuvaa perhospopulaatiota, joka elää maaseudulla paikassa, jossa ei ole juuri
        saasteita.
        Oikeanpuoleinen alue kuvaa perhospopulaatiota, joka elää kaupungissa alueella, jossa teollisuus tuottaa
        merkittävän määrän saasteita ja hiilipölyä. Onko tummien ja vaaleiden perhosten määrässä merkittävää eroa näiden
        kahden eri
        populaation välillä? <br> <br> -->
        // Lopullisessa tehtävässä eri vaiheiden järjestys olisi sekoitettu ja 1, 2b jne. sijasta näkyvissä esimerkiksi
        A, B, C. <br> <br>
        1. Vasemmalla oleva alue kuvaa perhospopulaatiota, joka elää maaseudulla, ja oikeanpuoleinen alue kuvaa
        perhospopulaatiota, joka elää kaupungissa. Yhdistä havainto (simulaatio/kuva) oikeaan vaiheeseen kuvauksen
        perusteella. <br>
        Painamalla kunkin vaiheen nappia näkyviin tulee 40 yksilön näytteet molemmista populaatioista. Otetut näytteet
        kunkin vaiheen osalta pysyvät muistissa ja voit vertailla niitä. Jos haluat generoida uudet näytteet, paina
        Uudet
        näytteet -nappia, jolloin näytteet generoituvat uudelleen valitun (näkyvissä olevan) vaiheen osalta. <br>
        (1a) Älä generoi uusia näytteitä, vaan käy ainoastaan läpi joka vaiheelle automaattisesti generoidut näytteet.
        Yritä päätellä oikeat vastaukset näiden pienten näytteiden
        perusteella. Kuinka varma olet siitä,
        että vastauksesi ovat oikeat?)
        (1b) Voit nyt käyttää Uudet näytteet -nappia niin monta kertaa kuin haluat ja kerätä suuremman määrän dataa.
        Muutitko vastauksiasi uusien näytteiden perusteella?
        Miten näytteiden määrä vaikuttaa siihen, kuinka varma vastaustesi oikeellisuudesta olet?)<br>
        Vaihe 1. Ennen teollistumista. Perhospopulaatiossa on keskimäärin sama määrä tummia yksilöitä riippumatta
        paikasta. <br>
        Vaihe 2a. Teollistuminen on alkanut, ja saasteiden ja nokipölyn määrä lisääntyy kaupungissa. Kaupungin
        perhospopulaatio ei ole vielä muuttunut merkittävästi verrattuna maaseutuun.<br>
        Vaihe 2b. Teollistuminen on alkanut, ja saasteiden ja nokipölyn määrä lisääntyy kaupungissa. Kaupungin
        perhospopulaatio on muuttunut merkittävästi verrattuna maaseutuun.<br>
        Vaihe 3. Kaupungissa on merkittävä määrä saasteita. Kaupungin populaatiossa on 70% tummia perhosia.<br>
        Vaihe 4. Kaupungissa on edelleen merkittävä määrä saasteita. Kaupungin populaatiossa on 95% tummia perhosia.
        <br>
        Vaihe 5. Kaupungin ilma on parantunut merkittävästi eikä nokipölyä enää ole, ja perhospopulaatio on palautumassa
        alkuperäiseen. Se ei kuitenkaan ole vielä täysin alkuperäisellä tasolla: kaupungin ja maaseudun välillä on
        edelleen eroa tummien ja vaaleiden yksilöiden suhteellisessa määrässä. <br><br>
        2. //Sampling// Valitse vaihe 1. Tässä vaiheessa molemmat populaatiot ovat identtiset, joten niiden voidaan ajatella olevan
        toistaiseksi samaa suurta populaatiota. Generoi uudet näytteet 10 kertaa ja merkitse jokaisen kerran osalta muistiin, montako tummaa
        yksilöä esiintyi (yhteensä 80:stä mahdollisesta yksilöstä) ja mikä niiden prosentuaalinen osuus oli.
        a) Mikä oli keskimääräinen tummien yksilöiden määrä ja keskimääräinen prosenttiosuus?
        b) Mikä oli suurin kerralla esiintynyt tummien yksilöiden määrä?
        c) Mikä oli pienin kerralla esiintynyt tummien yksilöiden määrä?
        d) Mikä oli vaihteluvälin suuruus? <br><br>

        3. //Confidence interval// Arvioi tummien perhosten osuutta koko populaatiossa yhden 40 yksilön näytteen perusteella. Laske 95%:n luottamusväli. 

    </div>

    <script>

        //TODO: separate refresh/regenerate button: can compare without refreshing sample. 
        const board = JXG.JSXGraph.initBoard('box', {
            boundingbox: [-20, 20, 20, -20],
            axis: true,
            showNavigation: false,
            showCopyright: false,
            axis: false
        });

        const columns = 5;
        const startY = 16;
        const startX = 3.5;
        const ySpacing = 4;

        let leftCounts = { white: 0, black: 0 };
        let rightCounts = { white: 0, black: 0 };
        const leftButterflies = [];
        const rightButterflies = [];
        let baseMelanisticProbability = 0.05;

        let colorsStage1 = { left: [], right: [] };
        let colorsStage2a = { left: [], right: [] };
        let colorsStage2b = { left: [], right: [] };
        let colorsStage3 = { left: [], right: [] };
        let colorsStage4 = { left: [], right: [] };
        let colorsStage5 = { left: [], right: [] };

        let currentStage = 0;

        const p1 = board.create('point', [-19, -19], { visible: false });
        const p2 = board.create('point', [-19, 19], { visible: false });
        const p3 = board.create('point', [0, 19], { visible: false });
        const p4 = board.create('point', [0, -19], { visible: false });
        const p5 = board.create('point', [19, -19], { visible: false });
        const p6 = board.create('point', [19, 19], { visible: false });

        const leftArea = board.create('polygon', [p1, p2, p3, p4], {
            color: 'lightgrey',
            fillOpacity: 0.7,
            highlight: false,
            borders: { highlight: false }
        });
        const rightArea = board.create('polygon', [p3, p4, p5, p6], {
            color: 'lightgrey',
            fillOpacity: 0.7,
            highlight: false,
            borders: { highlight: false }
        });

        const leftCounterText = board.create('text', [-10, -15, 'Vaaleita: -, Tummia: -'], { fontSize: 18, anchorX: 'middle', cssClass: 'text-with-bg', highlight: false })
        const rightCounterText = board.create('text', [10, -15, 'Vaaleita: -, Tummia: -'], { fontSize: 18, anchorX: 'middle', cssClass: 'text-with-bg', highlight: false })

        const stageText = board.create('text', [-16, 19, 'Vaihe: '], {
            fontSize: 16,
            color: 'white',
            cssClass: 'jsx-text',
            anchorX: 'middle',
            anchorY: 'middle',
            fixed: true,
            layer: 100,
            highlight: false
        });
        const newSampleBtn = board.create('text', [0, -15, 'Uudet näytteet'], {
            fontSize: 16,
            color: 'white',
            cssClass: 'jsx-button',
            anchorX: 'middle',
            anchorY: 'middle',
            fixed: true,
            layer: 100,
            highlight: false
        });

        newSampleBtn.on('down', function () {
            generateNewSample();
        });

        const coords = [
            [0, -0.5], [0.164, -0.939], [0.418, -0.848], [0.509, -0.545], [0.382, -0.242], [0.745, 0.061], [0.709, 0.636], [0.4, 0.97],
            [0, 0.227], [-0.4, 0.97], [-0.709, 0.636], [-0.745, 0.061], [-0.382, -0.242], [-0.509, -0.545], [-0.418, -0.848], [-0.164, -0.939],];

        function randomInt(min, max) {
            return Number(Math.floor(Math.random() * (max - min + 1)) + min);
        }

        function createButterfly(x, y, color = 'white', side = 'left') {
            const translated = coords.map(p => [p[0] + x, p[1] + y]);
            const shape = board.create('polygon', translated, {
                fillColor: color,
                fillOpacity: 0.9,
                borders: { visible: false },
                vertices: { visible: false },
                highlight: false
            });
            if (side == 'left') {
                leftButterflies.push(shape);
            } else {
                rightButterflies.push(shape);
            }

        }

        function createManyButterflies(number, side = 'left', probabilityOfMelanistic) {
            board.suspendUpdate();
            const sign = side == 'left' ? -1 : 1;
            const spots = [];
            for (let i = 0; i < number; i++) {
                const x = (startX + 3 * (i % columns)) * sign;
                const y = startY - ySpacing * Math.floor(i / columns);
                spots.push({ x: x, y: y });
            }
            spots.forEach(spot => {
                const color = Math.random() < probabilityOfMelanistic ? 'black' : 'white';
                if (side == 'left') {
                    if (color == 'black') leftCounts.black++;
                    else leftCounts.white++;
                }
                else {
                    if (color == 'black') rightCounts.black++;
                    else rightCounts.white++;

                }
                createButterfly(spot.x, spot.y, color, side)
            })
            board.unsuspendUpdate();
        }

        function recolorButterflies(array, colorArray, side, probabilityOfMelanistic,) {
            if (side == 'left') {
                leftCounts = { white: 0, black: 0 };
                colorArray.left.length = 0;
            }
            if (side == 'right') {
                rightCounts = { white: 0, black: 0 };
                colorArray.right.length = 0;
            }

            board.suspendUpdate();
            array.forEach(butterfly => {
                const color = Math.random() < probabilityOfMelanistic ? 'black' : 'white';
                butterfly.setAttribute({ fillColor: color });
                if (side == 'left') {
                    colorArray.left.push(color);
                    if (color == 'black') leftCounts.black++;
                    else leftCounts.white++;
                }
                else {
                    colorArray.right.push(color);
                    if (color == 'black') rightCounts.black++;
                    else rightCounts.white++;
                }
            })
            board.unsuspendUpdate();
        }
        function recolorFromArray(colorArray) {
            board.suspendUpdate();
            leftCounts.black = 0; leftCounts.white = 0;
            rightCounts.black = 0; rightCounts.white = 0;
            leftButterflies.forEach((obj, i) => {
                const c = colorArray.left[i];
                obj.setAttribute({ fillColor: c });
                if (c == 'black') leftCounts.black++;
                else leftCounts.white++;
            })
            rightButterflies.forEach((obj, i) => {
                const c = colorArray.right[i];
                obj.setAttribute({ fillColor: c });
                if (c == 'black') rightCounts.black++;
                else rightCounts.white++;
            })
            board.unsuspendUpdate();
            updateCounters();

        }

        function updateCounters() {
            leftCounterText.setText("Vaaleita: " + leftCounts.white + ", tummia: " + leftCounts.black)
            rightCounterText.setText("Vaaleita: " + rightCounts.white + ", tummia: " + rightCounts.black)
        }
        function updateStage() {
            let stage = currentStage.toString();
            if (stage == '21') stage = '2a';
            if (stage == '22') stage = '2b';
            stageText.setText("Vaihe: " + stage);
        }

        function stage1(refresh = false) {
            currentStage = 1;
            rightArea.setAttribute({ fillColor: 'lightgrey', fillOpacity: 0.7 });
            if (colorsStage1.left.length == 0 || refresh) {
                recolorButterflies(leftButterflies, colorsStage1, 'left', baseMelanisticProbability);
                recolorButterflies(rightButterflies, colorsStage1, 'right', baseMelanisticProbability);
                updateCounters();

            } else {
                recolorFromArray(colorsStage1);
            }
            updateStage();
        }
        function stage2a(refresh = false) {
            currentStage = 21;
            rightArea.setAttribute({ fillColor: 'black', fillOpacity: 0.6 });
            if (colorsStage2a.left.length == 0 || refresh) {
                recolorButterflies(leftButterflies, colorsStage2a, 'left', baseMelanisticProbability);
                recolorButterflies(rightButterflies, colorsStage2a, 'right', baseMelanisticProbability);
                updateCounters();
            } else {
                recolorFromArray(colorsStage2a);
            }
            updateStage();
        }
        function stage2b(refresh = false) {
            currentStage = 22;
            rightArea.setAttribute({ fillColor: 'black', fillOpacity: 0.6 });
            if (colorsStage2b.left.length == 0 || refresh) {
                recolorButterflies(leftButterflies, colorsStage2b, 'left', baseMelanisticProbability);
                recolorButterflies(rightButterflies, colorsStage2b, 'right', 0.2);
                updateCounters();
            } else {
                recolorFromArray(colorsStage2b);
            }
            updateStage();
        }
        function stage3(refresh = false) {
            currentStage = 3;
            rightArea.setAttribute({ fillColor: 'black', fillOpacity: 0.75 });
            if (colorsStage3.left.length == 0 || refresh) {
                recolorButterflies(leftButterflies, colorsStage3, 'left', baseMelanisticProbability);
                recolorButterflies(rightButterflies, colorsStage3, 'right', 0.7);
                updateCounters();
            } else {
                recolorFromArray(colorsStage3);
            }
            updateStage();
        }
        function stage4(refresh = false) {
            currentStage = 4;
            rightArea.setAttribute({ fillColor: 'black', fillOpacity: 0.75 });
            if (colorsStage4.left.length == 0 || refresh) {
                recolorButterflies(leftButterflies, colorsStage4, 'left', baseMelanisticProbability);
                recolorButterflies(rightButterflies, colorsStage4, 'right', 0.95);
                updateCounters();
            } else {
                recolorFromArray(colorsStage4);
            }
            updateStage();
        }
        function stage5(refresh = false) {
            currentStage = 5;
            rightArea.setAttribute({ fillColor: 'lightgrey', fillOpacity: 0.7 });
            if (colorsStage5.left.length == 0 || refresh) {
                recolorButterflies(leftButterflies, colorsStage5, 'left', baseMelanisticProbability);
                recolorButterflies(rightButterflies, colorsStage5, 'right', 0.15);
                updateCounters();
            } else {
                recolorFromArray(colorsStage5);
            }
            updateStage();
        }

        function generateNewSample() {
            switch (currentStage) {
                case 1:
                    stage1(true);
                    break;
                case 21:
                    stage2a(true);
                    break;
                case 22:
                    stage2b(true);
                    break;
                case 3:
                    stage3(true);
                    break;
                case 4:
                    stage4(true);
                    break;
                case 5:
                    stage5(true);
                    break;
            }
        }

        createManyButterflies(40, 'right', 0.05);
        createManyButterflies(40, 'left', 0.05);
        stage1();

    </script>

</body>

</html>