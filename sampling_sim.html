<!DOCTYPE html>
<html>

<head>
    <title>JSXGraph Example</title>
    <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
    <style>
        #box {
            width: 1200px;
            height: 600px;
        }
    </style>
</head>

<body>

    <div id="box" class="jxgbox"></div>
    <div>
        <button onclick="reveal()"> Reveal</button>
    </div>

    <pre>
Ohje/tehtävät:

Klikkaa "yksilöä" (palloa) ottaaksesi näytteen, joka paljastaa yksilön värin. 
1. Ota satunnaisesti 15 näytettä populaatiosta. Millainen värijakauma otoksessasi on? Luuletko, että otoksen jakauma on sama 
kuin koko populaation jakauma?
2. Ota satunnaisesti 30 näytettä lisää. Millainen jakauma on nyt? Muuttuiko se paljon? Luuletko, että otoksen jakauma kuvaa 
nyt hyvin koko populaation jakaumaa?
3. Ota harkintasi mukaan lisää näytteitä, kunnes uskot saaneesi selville koko populaation värijakauman [5% tarkkuudella], ja
kirjoita tuloksesi ylös. 
4. Paina 'Reveal'-nappia paljastaaksesi kaikkien populaation yksilöiden värit ja todellisen värijakauman. Oliko arviosi 
onnistunut?


    </pre>

    <script>
        const board = JXG.JSXGraph.initBoard('box', {
            boundingbox: [0, 20, 40, 0],
            axis: false, 
            showNavigation: false, 
            showCopyright: false
        });

        //TODO: show percentages instead?
        //add labels below bar graphs
        //add counter of how many have been revealed

        const gridSize = 15;
        const pointRadius = 10;
        const gridYStart = 2.5;
        const gridXStart = 0.5;

        const cells = [];
        const bars = [];
        const labels = [];

        const frequencies = {
            white: 0,
            lightblue: 0,
            orange: 0,
            plum: 0,
            pink: 0,

        }
        const finalrequencies = {
            white: 0,
            lightblue: 0,
            orange: 0,
            plum: 0,
            pink: 0,

        }

        function getColor() {
            const rand = Math.random();
            if (rand < 0.2) return 'white';
            else if (rand < 0.6) return 'lightblue';
            else if (rand < 0.7) return 'orange';
            else if (rand < 0.75) return 'plum';
            else return 'pink';

        }


        for (let row = 0; row < gridSize; row++) {
            cells[row] = [];
            for (let col = 0; col < gridSize; col++) {
                const x = col + 0.5 + gridXStart;
                const y = row + 0.5 + gridYStart;

                const cell = board.create('point', [x, y], {
                    fixed: true,
                    size: pointRadius,
                    name: '',
                    color: 'grey',
                    highlight: false,
                    showInfobox: false
                });
                const color = getColor();
                cell.customState = { color: color, hidden: true }
                cell.on('down', () => {
                    if (cell.customState.hidden) {
                        cell.setAttribute({ fillColor: color });
                        addToFreq(color);
                        updateBars();
                    }
                });
                cells[row][col] = cell;
            }
        }

        function getBarColor(n) {
            if (n == 0) {
                return 'white';
            }
            else if (n == 1) { return 'lightblue'; }
            else if (n == 2) { return '#FFA500'; }
            else if (n == 3) { return 'plum'; }
            else { return 'pink'; }
        }

        function reveal() {
            board.suspendUpdate();
            for (let row = 0; row < cells.length; row++) {
                for (let col = 0; col < cells[row].length; col++) {
                    const cell = cells[row][col];
                    cell.setAttribute({ fillColor: cell.customState.color });
                    addToFinalFreq(cell.customState.color);
                }
            }
            board.unsuspendUpdate();
            showFinalBars();

        }

        function showFinalBars() {
            const freqArray = Object.values(finalrequencies);
            drawHistogram(board, freqArray, baseX = 30)

        }
        function updateBars() {
            const freqArray = Object.values(frequencies);
            bars.forEach(obj => board.removeObject(obj));
            bars.length = 0;
            labels.forEach(obj => board.removeObject(obj));
            labels.length = 0;
            drawHistogram(board, freqArray)

        }


        function addToFreq(color) {
            frequencies[color] = (frequencies[color] || 0) + 1;
        }
        function addToFinalFreq(color) {
            finalrequencies[color] = (finalrequencies[color] || 0) + 1;
        }

        function drawHistogram(board, frequencies, baseX = 20, baseY = 2, maxHeight = 15) {

            const barWidth = 0.8;
            const maxCount = Math.max(...frequencies);

            for (let i = 0; i < frequencies.length; i++) {
                const color = getBarColor(i % 5);
                const x0 = baseX + i * (barWidth + 0.2);
                const x1 = x0 + barWidth;
                const y1 = baseY + (frequencies[i] / maxCount) * maxHeight;

                bars.push(board.create('polygon', [
                    [x0, baseY],
                    [x1, baseY],
                    [x1, y1],
                    [x0, y1]
                ], {
                    fillColor: color,
                    fillOpacity: 0.6,
                    strokeColor: '#339',
                    strokeWidth: 1,
                    fixed: true,
                    vertices: { visible: false }
                }));

                labels.push(board.create('text', [x0 + barWidth / 2, y1 + 0.2, `${frequencies[i]}`], {
                    anchorX: 'middle',
                    anchorY: 'bottom',
                    fixed: true
                }));
            }
        }


    </script>

</body>

</html>