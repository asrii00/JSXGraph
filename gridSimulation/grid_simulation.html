<!DOCTYPE html>
<html>

<head>
  <title>JSXGraph Example</title>
  <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
  <script src="altitudeMapSmall.js"></script>
  <script src="predationMapSmall.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
  <style>
    #box {
      width: 900px;
      height: 600px;
    }

    div {
      margin: 7px;
    }
  </style>
</head>

<body>
  <div id="box" class="jxgbox"></div>
  <div class="flex">
    <button onClick="step()"> Step </button>
    <button onClick="tenStep()"> 10 steps </button>
    <!-- <button onClick="set()"> Set chosen traits </button> -->
  </div>

  <script>
    //TODO: implement environment conditions in probability
    const board = JXG.JSXGraph.initBoard('box', {
      boundingbox: [-1, 21, 31, -1],
      axis: true,
      showCopyright: false,
      showNavigation: false
    });

    const gridSize = 20;
    const cellSize = 1;
    const baseDeathProbability = 0.05;
    const baseOffspringProbability = 0.4;

    const startX = 9.5; //square x = 10
    const startY = 10.5;

    let individuals = [];
    const rectangles = [];

    const occupied = new Set();

    let hasStarted = false;

    const budget = 1.2;
    let altitudePref = 0.33;
    let altitudeLeeway = 0.4;
    let predationResistance = 0.33;
    let droughtResistance = 0.33;

    const s1 = board.create('slider', [[21, 4], [25, 4], [0, 0.33, 1]], { name: 'Altitude preference' });
    const s2 = board.create('slider', [[21, 3], [25, 3], [0, 0.33, 1]], { name: 'Predation resistance' });
    const s3 = board.create('slider', [[21, 2], [25, 2], [0, 0.33, 1]], { name: 'Drought resistance' });


    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {

        const altitude = altitudeMapSmall[y][x];
        const predation = predationMapSmall[y][x];

        const b = Math.floor(255 - predation * 255);
        const g = Math.floor(255 - altitude * 255);
        const r = 200;
        const color = `rgb(${r},${g},${b})`;

        const rect = board.create('polygon', [
          [x, y],
          [x + cellSize, y],
          [x + cellSize, y + cellSize],
          [x, y + cellSize]
        ], {
          fillColor: color,
          fillOpacity: 1.0,
          borders: { strokeWidth: 1 },
          vertices: { visible: false }
        });
      }
    }

    function createIndividual(x, y) {
      const key = `${x},${y}`;
      if (!occupied.has(key)) {
        occupied.add(key);
        const individual = board.create('point', [x, y], { color: 'green', size: 8, fixed: true, showInfobox: false, name: '' });
        individual.dead = false;
        individuals.push(individual);
      }
    }

    function getOffspringPosition(oldX, oldY) {

      const deltaX = (Math.random() > 0.5) ? -1 : 1;
      const deltaY = (Math.random() > 0.5) ? -1 : 1;
      let newX = oldX;
      let newY = oldY;
      const rand = Math.random();

      if (rand < 0.33) {
        newX += deltaX;
      }
      else if (rand < 0.66) {
        newY += deltaY;
      }
      else {
        newX += deltaX;
        newY += deltaY;
      }

      const posObject = { x: newX, y: newY };
      return posObject;
    }

    function kill(i) {
      individuals[i].setAttribute({ color: 'grey' })
      individuals[i].dead = true;
    }

    function reproduce(i) {
      const newPos = getOffspringPosition(individuals[i].X(), individuals[i].Y());
      if (newPos.x < 0 || newPos.x > 20 || newPos.y < 0 || newPos.y > 20) {
        //console.log('Out of bounds')
      }
      else {
        createIndividual(newPos.x, newPos.y);
      }

    }
    function getRandomArbitrary(min, max) {
      return Math.random() * (max - min) + min;
    }

    //test version
    function getSurvivalSuccess(altitude, predation, drought) {
      const baseSurvival = 1.3 + (Math.random() - 0.5); //0.5-1.5
      const baseSurvivalRequirement = (Math.random()); //0.0-1.0
      return baseSurvival > baseSurvivalRequirement;
    }

    function getAltitudeSurvivalSuccess(altitude, predation, drought) {
      const altitudePrefMin = altitudePref - altitudeLeeway;
      const altitudePrefMax = altitudePref + altitudeLeeway;
      const randomJitter = getRandomArbitrary(-0.25, 0.25);
      const altitudeSurvivalMin = altitude + randomJitter;
      const altitudeSurvivalMax = altitude + randomJitter;
      return (altitudeSurvivalMin > altitudePrefMin && altitudeSurvivalMax < altitudePrefMax); //returns boolean :)
    }

    function step() {
      hasStarted = true;
      for (let i = 0; i < individuals.length; i++) {
        const randomOffspringValue = Math.random()
        if (!individuals[i].dead) {
          const gridX = Math.floor(individuals[i].X());
          const gridY = Math.floor(individuals[i].Y());

          // ChatGPT recommended guard: skip if out of bounds (defensive check)
          if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) continue;
          //

          const altitude = altitudeMapSmall[gridY][gridX];
          const predation = predationMapSmall[gridY][gridX];
          if (!getAltitudeSurvivalSuccess(altitude)) {
            kill(i);
          }

          if (randomOffspringValue < baseOffspringProbability) {
            reproduce(i);
          }
        }
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function tenStep() {
      for (let i = 0; i < 10; i++) {
        step();
        await sleep(100); // Delay 100ms between steps
      }

    }

    function set() {
      console.log('traits set');
      altitudePref = s1.Value();
      predationResistance = s2.Value();
      droughtResistance = s3.Value();
      console.log('altitude: ', altitudePref);

    }

    function updateLimits(changedSlider) {
      const v1 = s1.Value();
      const v2 = s2.Value();
      const v3 = s3.Value();
      const remainingBudget = budget;

      if (changedSlider !== s1) {
        const max1 = Math.max(0, remainingBudget - v2 - v3);
        if (v1 > max1) s1.setValue(max1);
      }
      if (changedSlider !== s2) {
        const max2 = Math.max(0, remainingBudget - v1 - v3);
        if (v2 > max2) s2.setValue(max2);
      }
      if (changedSlider !== s3) {
        const max3 = Math.max(0, remainingBudget - v1 - v2);
        if (v3 > max3) s3.setValue(max3);
      }

      if (!hasStarted) {
        set();
      }
    }

    s1.on('drag', () => updateLimits(s1));
    s2.on('drag', () => updateLimits(s2));
    s3.on('drag', () => updateLimits(s3));

    createIndividual(startX, startY);


  </script>

</body>

</html>