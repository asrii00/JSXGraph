<!DOCTYPE html>
<html>

<head>
  <title>JSXGraph Example</title>
  <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
  <style>
    #box {
      width: 1200px;
      height: 400px;
    }

    .flex-container {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      padding: 10px;
    }
  </style>
</head>

<body>
  <div class="flex-container">
    <div id="box" class="jxgbox"></div>
  </div>
  <div>
    <button onclick="setRandom()">Generate random</button>

  </div>
  <div style="margin-top: 1em;">
    <label for="base-output">Sekvenssi tekstin√§</label><br>
    <textarea id="base-output" rows="4" cols="99" readonly style="resize: none; font-family: monospace;"></textarea>
  </div>

  <script>
    //TODO: 
    // label axes properly, remove gap between A and B charts, think about sensible scaling, maybe increase bar number
    // also draw graphs of made up sequences 
    // figure out how to compare them in a good way

    const board = JXG.JSXGraph.initBoard('box', {
      boundingbox: [-125, 100, 200, -10],
      axis: true,
      showNavigation: true,
    });

    const madeUpSeries = 'ABBAAABABABBBABABABBABABABBABBBABABAAABB'
    const coinColors = {
      A: '#EA8B1E',
      B: '#E8B927'
    };

    const radius = 5;
    const columns = 10;
    const startX = -110;
    const startY = 25;
    const ySpacing = 15;

    const circles = [];
    const circleLabels = [];
    let results = {};

    const labels = [
      '1', '2', '3', '4',
      '5', '6', '7', '8',
      '9', '10'
    ];

    const xPositions = labels.map((_, i) => 15 * i + 15);

    function drawCircle(x, y, base, color) {
      circles.push(board.create('circle', [
        [x, y], radius
      ], {
        strokeColor: color,
        fillColor: color,
        fillOpacity: 0.8,
        strokeWidth: 2,
        fixed: true
      }));
      circleLabels.push(board.create('text', [
        x, y, base
      ], {
        anchorX: 'middle',
        anchorY: 'middle',
        fontSize: 14,
        fixed: true
      }));
    }

    function getPositionForIndex(index) {
      const x = startX + 2 * radius * (index % columns);
      const y = startY + ySpacing * Math.floor(index / columns);
      return { x: x, y: y };
    }

    function randomize() {
      let randomString = '';
      for (let i = 0; i < 40; i++) {
        randomString += ((Math.random() > 0.5) ? 'A' : 'B')
      }
      return randomString;
    }

    function setRandom() {
      clearEverything();
      let generated = randomize();
      draw(generated);
      results = countRuns(generated, results)
      //console.log(results);
      updateChart();
    }

    function countRuns(seq, result) { //By ChatGPT, couldn't figure this bit out by myself.
      let currentChar = seq[0];
      let runLength = 1;

      for (let i = 1; i < seq.length; i++) {
        if (seq[i] === currentChar) {
          runLength++;
        } else {
          // Store the current run
          if (!result[currentChar]) result[currentChar] = {};
          result[currentChar][runLength] = (result[currentChar][runLength] || 0) + 1;

          currentChar = seq[i];
          runLength = 1;
        }
      }

      // Handle final run
      if (!result[currentChar]) result[currentChar] = {};
      result[currentChar][runLength] = (result[currentChar][runLength] || 0) + 1;

      return result;
    }

    let chart = board.create('chart', [xPositions, [0, 0, 0]], { chartStyle: 'bar', width: 1, }) //doesn't display

    function updateChart() {
      board.removeObject(chart);
      const letters = Object.keys(results); // A, B
      let newData = []; 

      const A = results.A;
      const B = results.B;
      let total = 0;

      for (let i = 1; i <= 10; i++) {
        const key = i.toString();
        newData.push(A[key] || 0);  // value from A, or 0 if missing
        total += (A[key] || 0);
        newData.push(B[key] || 0);  // value from B, or 0 if missing
        total += (B[key] || 0);
      }
      //console.log(newData);
      const dividedArray = newData.map(num => num / total * 100);
      //console.log('divided ', dividedArray)

      chart = board.create('chart', [xPositions, newData],
        {
          chartStyle: 'bar', width: 10,
          colors: [coinColors.A, coinColors.B]
        });
    }

    function drawCoin(side, index, color) {
      const pos = getPositionForIndex(index);
      drawCircle(pos.x, pos.y, side, color);
    }

    function draw(string) {
      for (let i = 0; i < string.length; i++) {
        const side = string[i];
        drawCoin(side, i, coinColors[side])
      }
      document.getElementById('base-output').value = string;
    }

    function clearEverything() {
      document.getElementById('base-output').value = '';

      circles.forEach(circle => board.removeObject(circle));
      circleLabels.forEach(label => board.removeObject(label));
      circles.length = 0;
      circleLabels.length = 0;
    }
    //draw(madeUpSeries);


  </script>

</body>

</html>